\chapter{Dasar Teori}
\label{chap:dasar teori}

Sebelum bisa membuat \textit{Twitter bot} untuk mencari jalur transportasi publik, berikut diberikan beberapa definisi yang berkaitan dengan pembuatan \textit{Twitter bot}. Bab ini akan menjelaskan Twitter, Twitter API, KIRI, KIRI API, dan Twitter4j.

\section{Twitter}
\label{sec:twitter}

Twitter adalah salah satu layanan jejaring sosial online yang memungkinkan pengguna melakukan \textit{posting} pesan berbasis teks hingga 140 karakter\cite{TwitterBook}. Berikut ini adalah daftar istilah umum pada Twitter:


\begin{itemize}
	\item \textit{Tweet} 
	
	Posting pada Twitter disebut sebagai \textit{tweet}. \textit{Tweet} ini akan meneruskan pesan singkat yang ditujukan ke semua \textit{follower} suatu akun\footnote{Dusty Reagan, \textit{Twitter Application Development For Dummies}, Wiley, 2010, page 7}. Contohnya adalah seorang akun @kviniink ingin menuliskan bahwa hari ini cuaca cerah, maka akun @kviniink akan melakukan \textit{tweet} 'Hari ini cerah yah..'. \textit{Tweet} juga bisa menyertakan \textit{link} untuk video, foto, atau media lain di internet selain teks biasa. URL(\textit{Uniform resource locator}) \textit{link} teks termasuk ke dalam 140 batas karakter, namun URL tersebut akan menghabisnya tempat/\textit{space} dari keterbatasan karakter \textit{tweet}. Oleh karena itu, URL akan dibuat versi singkatnya, contohnya pada saat pengguna memasukkan \textit{link} \url{http://www.chacha.com/gallery/7253/15-movies-that-make-guys-cry}, maka \textit{link} tersebut akan dibuat menjadi \url{bit.ly/1uRi8vV}. 
	\item \textit{Follow}Uniform resource locator
	
	\textit{Follow} adalah satu istilah dalam Twitter yang bertujuan untuk mengikuti aktivitas \textit{tweet} suatu akun. \textit{Following} adalah ketika sebuah akun mengikuti akun orang lain, dan \textit{Follower} adalah ketika sebuah akun melakukan aksi \textit{follow} kepada akun anda.
	\item \textit{Reply} 
	
	\textit{Reply} adalah cara seseorang untuk dapat memberi rujukan kepada akun Twitter yang lainnya atau lebih dikenal dengan nama \textit{mention}\footnote{Dusty Reagan, \textit{Twitter Application Development For Dummies}, Wiley, 2010, page 9}. Sebagai contoh, diketahui akun bernama @kviniink mem-\textit{follow} @infobdg untuk mengetahui perkembangan apa saja yang tejadi di Kota Bandung. Lalu akun @kviniink ingin bertanya tentang info \textit{mall} yang sedang ramai dikunjungi di Kota Bandung, maka akun @kviniink membuat \textit{mention tweet} yang berisikan "@infobdg Halo saya ingin bertanya apa saja mall yang sedang ramai dikunjungi di Bandung yah?".
	\item \textit{Retweet}
	
	\textit{Retweet} ini merupakan salah satu istilah penting dari Twitter. \textit{Retweet} ini berguna ketika pengguna menemukan \textit{tweet} menarik dan ingin  berbagi \textit{tweet} tersebut dengan \textit{follower} akun tersebut. \textit{Retweet} ini juga secara tidak langsung mengatakan bahwa "saya menghormati anda dan pesan yang anda buat" \cite{TwitterBook}.
	\item \textit{Hashtag}
	
	Sebuah fitur yang diciptakan oleh Twitter untuk membantu pencarian kata kunci dan penandaan suatu diskusi.
	
	\item \textit{Direct Message}(DM)
	
	\textit{Direct message} digunakan untuk mengirim pesan yang bersifat \textit{private} antara dua akun Twitter. Syarat agar dapat melakukan \textit{direct message} adalah melakukan aksi \textit{follow} terhadap akun yang akan dikirimkan \textit{direct message}.
	\item \textit{Timeline}
	
	\textit{Timeline} adalah sekumpulan \textit{tweet} dari semua akun yang di-\textit{follow}. \textit{Timeline }ditampilkan di halaman utama.
\end{itemize}


\section{Twitter API}
Twitter API(\textit{Application programming interface}) adalah aplikasi pihak ketiga yang memungkinkan pengembang perangkat lunak melakukan manipulasi dan pengolahan data di Twitter. Twitter API adalah salah satu bentuk pendekatan dari Twitter yang berfokus pada jaringan dan memungkinkan pengembang perangkat lunak memiliki hak untuk berpikir '\textit{out of the box}' untuk membuat aplikasi yang mereka inginkan\cite{Twitter}. Tetapi tetap akan terjadi keterbatasan yang dimiliki Twitter API, yaitu :
\begin{itemize}
	\item Hanya bisa melakukan \textit{tweet} 1000 per harinya, baik melalui \textit{handphone}, \textit{website}, API, dan sebagainya.
	\item Total pesan hanya bisa sebanyak 250 per harinya, pada setiap dan semua perangkat.
	\item 150 permintaan API per jam.
	\item OAuth diijinkan 350 permintaan per jam.
\end{itemize}

\subsection{\textit{Search} API}

Twitter \textit{Search} API memungkinkan melakukan pencarian terhadap \textit{tweet} baru ataupun \textit{tweet} populer. Tetapi Twitter \textit{Search} API ini bukan fitur yang tersedia pada Twitter itu sendiri. API ini difokuskan kepada relevansi, bukan terhadap kelengkapan data\cite{Twitter}. Ini berarti bahwa ada beberapa \textit{Tweet} atau akun akan hilang dari hasil pencarian.

\paragraph{Bagaimana cara membuat sebuah \textit{query}}
Cara terbaik dalam membuat sebuah \textit{query} adalah melakukan percobaan yang valid dan mengembalikan \textit{tweet} yang sesuai. Cara mencobanya dapat dilakukan pada \url{twitter.com/search}. URL yang ditampilkan pada browser akan berisi sintaks \textit{query} yang sesuai agar dapat digunakan kembali pada Twitter API. Berikut adalah contohnya:

\begin{enumerate}
	\item Melakukan pencarian untuk \textit{tweet} yang di-\textit{mention} kepada akun @twitterapi. Pencarian dilakukan pada \url{twitter.com/search}.
	\item Lakukan pengecekan dan salin URL yang ditampilkan pada browser. Sebagai contoh didapatkan URL seperti \url{https://twitter.com/search?q=\%40twitterapi}.
	\item Ganti \url{https://twitter.com/search} dengan \url{https://api.twitter.com/1.1/search/tweets.json} dan akan didapatkan \url{https://api.twitter.com/1.1/search/tweets.json?q=\%40twitterapi}
	\item Eksekusi URL tersebut untuk melakukan pencarian di dalam API.
\end{enumerate}

API v1.1 mewajibkan \textit{request} yang sudah diotentikasi. Perlu diingat juga bahwa hasil pencarian yang dilakukan di \url{twitter.com} dapat menghasilkan data yang sudah sangat lama, sedangkan \textit{Search} API hanya melayani \textit{tweet} dari seminggu terakhir. Contoh berbagai macam pencarian dapat dilihat pada tabel \ref{tab:MacamPencarianTweet}:

\begin{table}[h]
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\textbf{Operator}          					& \textbf{Finds \textit{tweets}}                                            \\ \hline
\textit{watching now}               & Mengandung kata "\textit{watching}" dan "\textit{now}".						       \\
"\textit{happy hour}"               & Mengandung frase "\textit{happy hour}" yang tepat.                                 \\
\textit{love OR hate}               & Mengandung kata "\textit{love}" atau "\textit{hate}" atau keduanya.                             \\
\textit{beer -root}                 & Mengandung kata "\textit{beer}" tanpa adanya kata "\textit{root}".                                         \\
\#haiku                    					& Mengandung \textit{hashtag} "\textit{haiku}".                                            \\
\textit{from}:alexiskold            & Dikirim melalui akun "alexiskold".                                            \\
\textit{to}:techcrunch              & Dikirimkan kepada akun "techcrunch".                                              \\
@mashable                  					& Mereferensi kepada akun "mashable".                                            \\
\textit{superhero since}:2010-12-27 & Mengandung kata "\textit{superhero}" dari tanggal "2010-12-27" (tahun-bulan-hari). \\
\textit{ftw until}:2010-12-27       & Mengandung kata "\textit{ftw}" sebelum tanggal "2010-12-27".                   \\
\textit{movie -scary} :)            & Mengandung kata "\textit{movie}", tanpa adanya kata "\textit{scary}", dengan pencarian yang positif.        \\
\textit{flight} :(                  & Mengandung kata "\textit{flight}" dengan pencarian yang negatif.                         \\
\textit{traffic} ?                  & Mengandung kata "\textit{traffic}" dan mengandung pertanyaan.                               \\
\textit{hilarious filter:links}     & Mengandung kata "\textit{hilarious}" yang di sambungkan dengan URL.                                \\
\textit{news source:twitterfeed}    & Mengandung kata "\textit{news}" yang di-\textit{posting} melalui \textit{twitterfeed}.						\\        \hline                     
\end{tabular}
\caption{Contoh berbagai macam pencarian \textit{tweet}}
\label{tab:MacamPencarianTweet}
\end{table}

Dipastikan bahwa pengkodean URL terhadap \textit{query} dilakukan terlebih dahulu sebelum melakukan \textit{request}. Tabel \ref{tab:ContohMappingDariSeachQuery} memberikan contoh \textit{mapping} dari \textit{search query} ke \textit{query} pengkodean URL.

\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
\textbf{\textit{Search query}}     & \textbf{\textit{URL encoded query}}                 \\ \hline
\#haiku \#poetry & \%23haiku+\%23poetry              \\
"\textit{happy hour}" :)  & \%22\textit{happy}\%20\textit{hour}\%22\%20\%3A\%29 \\ \hline
\end{tabular}
\caption{Contoh \textit{mapping} dari \textit{search query} ke \textit{query} pengkodean URL}
\label{tab:ContohMappingDariSeachQuery}
\end{table}

\paragraph{\textit{Additional parameters}}
Terdapat parameter tambahan yang dapat digunakan untuk menghasilkan pencarian yang lebih baik. Berikut adalah penjelasan dari parameter tambahan tersebut :

\begin{itemize}
	\item \textbf{\textit{Result Type}}. Seperti hasil yang terdapat pada \url{twitter.com/search}, parameter \textit{result\_type} memungkinkan hasil pencarian akan berdasarkan \textit{tweet} yang paling baru atau \textit{tweet} yang paling populer atau bahkan gabungan dari keduanya.
	\item \textit{\textbf{Geolocatization}}. Pencarian tempat tidak tersedia pada API, tetapi ada beberapa cara yang tepat untuk membatasi \textit{query} dengan cara menggunakan parameter \textit{geocode} lalu menentukan "\textit{latitude, longitude, radius}". Contohnya adalah "37.781157,-122.398720,1mi". Ketika pencarian lokasi, pencarian API akan mencoba menemukan \textit{tweet} yang memiliki \textit{latitude} dan \textit{longitude} yang sudah dimasukkan kedalam \textit{query geocode}, jika tidak berhasil maka API akan mencoba menemukan \textit{tweet} yang dibuat oleh pengguna yang lokasi profilenya terdapat pada \textit{latitude} dan \textit{longitude} tersebut. Kesimpulannya adalah hasil pencarian dapat menerima \textit{tweet} yang tidak mencakup informasi \textit{latidute} atau \textit{longitude}.
	\item \textit{\textbf{Language}}. Bahasa dapat dijadikan parameter untuk mencari \textit{tweet} yang sesuai dengan bahasa yang dipilih.
	\item \textbf{\textit{Iterating in a result set}}. Parameter seperti \textit{count, until, since\_id, max\_id} memungkinkan untuk melakukan kontrol bagaimana iterasi melalui hasil pencarian.
\end{itemize}

\paragraph{\textit{Rate limits}}
\textit{User} pada saat ini diwakilkan oleh \textit{access tokens} yang dapat membuat 180 \textit{request} per 15 menit. Tetapi kita bisa membuat 450 \textit{request} per 15 menit dengan menggunakan \textit{application-only authentication} atas nama sendiri tanpa konteks pengguna.

\paragraph{Contoh Pencarian}
Ketika anda mengikuti suatu acara yaitu \textit{superbowl}, lalu anda tertarik untuk mencari hal yang sedang terjadi di acara tersebut dengan melihat \textit{tweet} yang paling baru dan menggunakan \textit{hashtag} dari acara tersebut, maka langkah-langkah yang dilakukan adalah:
\begin{itemize}
	\item Anda ingin mencari \textit{tweet} yang paling baru dengan menggunakan \textit{hashtag} \#\textit{superbowl}
	\item Maka \textit{search} URL akan seperti ini:
	\url{https://api.twitter.com/1.1/search/tweets.json?q=\%23superbowl\&result\_type=recent}
\end{itemize}

Ketika anda ingin mengetahui \textit{tweet} yang datang dari suatu lokasi dengan bahasa yang spesifik, maka langkah-langkah yang dilakukan adalah:
\begin{itemize}
	\item Anda ingin mencari \textit{tweet} yang paling baru dalam Bahasa Portugal, yang lokasinya dekat Maracana soccer stadium yang terletak di Rio de Janeiro.
	\item Maka search URL akan seperti ini:
	\url{https://api.twitter.com/1.1/search/tweets.json?q=\&geocode=-22.912214,-43.230182,1km\&lang=pt\&result\_type=recent}
	
Ketika anda ingin mencari \textit{tweet} yang sedang poluler dari spesifik \textit{user} dan \textit{tweet} tersebut terdapat sebuah hashtag tertentu, maka langkah-langkah yang dilakukan adalah:
\begin{itemize}
	\item Anda ingin mencari \textit{tweet} yang populer yang berasal dari \textit{user} @kviniink yang terdapat \textit{hashtag} \#nasa.
	\item Maka \textit{search} URL akan seperti ini:
	\url{https://api.twitter.com/1.1/search/tweets.json?q=from\%3Akviniink\%20\%23nasa\&result\_type=popular}
\end{itemize}
\end{itemize}

\subsection{Streaming API}
\textit{Streaming} API adalah contoh \textit{real-time} API. API ini ditujukan bagi para developer dengan kebutuhan data yang intensif. \textit{Streaming} API memungkinkan melacak kata kunci yang ditentukan dalam jumlah besar dan melakukan suatu aksi (seperti \textit{tweet}) secara langsung atau \textit{real-time}\cite{Twitter}.

Twitter menawarkan beberapa \textit{endpoint streaming}, disesuaikan dengan kasus yang dibutuhkan. 
\begin{itemize}
	\item \textit{Public stream}
	
	\textit{Public stream} merupakan \textit{streaming} data publik yang mengalir melalui Twitter. \textit{Public stream} Digunakan untuk mengikuti sebuah \textit{user} atau topik tertentu. \textit{Public stream} biasa  digunakan untuk \textit{data mining}.
	\item \textit{User Stream}
	
	{User Stream} merupakan \textit{Single-user streams} yang mengandung hampir semua data yang berhubungan dengan satu \textit{user} tertentu.
	
	\item \textit{Site Stream}
	
	\textit{Site Stream} merupakan versi dari \textit{multi-user stream}. \textit{Site stream} terhubung dengan server yang terkoneksi dengan Twitter atas nama banyak pengguna.
\end{itemize}


\paragraph{\textit{Public Streams}}
\textit{Stream} ini menawarkan sampel data publik yang mengalir melalui Twitter. Ketika aplikasi membuat sambungan ke \textit{streaming endpoint}, perangkat lunak akan mengambil \textit{tweet} tanpa perlu khawatir akan keterbatasan \textit{rate limit}.

\paragraph{\textit{Endpoints}}
	
	\begin{itemize}
		\item POST statuses / \textit{filter}
		\item GET statuses / \textit{sample}
		\item GET statuses / \textit{firehose}
	\end{itemize}

\paragraph{POST statuses/\textit{filter}}
POST \textit{filter} dapat mengembalikan status publik yang sesuai dengan satu atau lebih predikat yang telah difilter. \textit{Multiple parameter} memungkinkan klien untuk menggunakan koneksi tunggal untuk ke \textit{Streaming} API. Antara GET \textit{request} dan POST \textit{request} keduanya didukung oleh POST statuses / \textit{filter} tetapi untuk GET \textit{request} yang memiliki parameter yang terlalu banyak mungkin akan ditolak karena URL yang terlalu panjang. Gunakanlah POST request untuk menghindari URL yang panjang.
\textit{Track, follow}, dan lokasi harus dipertimbangkan untuk dapat digabungkan dengan operator OR. \textit{track}=foo\&\textit{follow}=1234 ini mengembalikan \textit{tweet} yang memiliki kata "foo" atau dibuat oleh \textit{user} 1234.
Akses standar mengizinkan pencarian hingga 400 kata kunci, dan 5000 \textit{follow userids}. Perintah ini dikembalikan dalam format JSON, memerlukan otentikasi \textit{user context}, dan frekuensi pemakaiannya dibatasi. Parameter untuk POST statuses/\textit{filter} dapat dilihat pada tabel \ref{table:ParameterPostStatusesFilter}

%\paragraph{\textit{Resource Information}}
%\begin{table}[!htbp]
%\begin{tabular}{|l|l|}
%\hline
%\textit{Response formats}         & JSON                    \\ \hline
%\textit{Requires authentication}? & Ya (hanya \textit{user context}) \\ \hline
%\textit{Rate limited}?            & Ya                    \\ \hline
%\end{tabular}
%\end{table}


\begin{table}[h]
\begin{tabular}{|p{3cm}|p{11cm}|}
\hline
\textit{follow}          & Menentukan pencarian \textit{tweet} dari suatu akun. \\ \hline
\textit{track}           & Kata kunci pencarian untuk di-\textit{track}.              \\ \hline
\textit{locations}       & Menentukan lokasi yang dilacak.                                                    \\ \hline
\textit{delimited}       & Menentukan apakah pesan harus dibatasi limitnya.                                         \\ \hline
\textit{stall\_warnings} & Menentukan apakah pesan warning harus dikirim atau tidak. \\ \hline                                        
\end{tabular}
\caption{Parameter POST statuses/\textit{filter}}
\label{table:ParameterPostStatusesFilter}
\end{table}


\paragraph{GET \textit{statuses/sample}}
Mengembalikan \textit{random} sampel dari semua status publik. Jika terdapat dua \textit{client} yang terhubung dengan \textit{endpoint} ini, maka kedua \textit{client} tersebut akan melihat \textit{tweet} yang sama. Perintah ini dikembalikan dalam format JSON, memerlukan otentikasi \textit{user context}, dan frekuensi pemakaiannya dibatasi. Parameter GET \textit{statuses/sample} dapat dilihat pada tabel \ref{table:ParameterGetStatusesSample}

\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
\textit{delimited}          & Menentukan apakah pesan harus dibatasi limitnya. \\ \hline
\textit{stall\_warning}           & Menentukan apakah pesan warning harus dikirim atau tidak.                \\   \hline          
\end{tabular}
\caption{Parameter GET \textit{statuses/sample}}
\label{table:ParameterGetStatusesSample}
\end{table}


\paragraph{GET \textit{statuses/firehose}}
Mengembalikan semua status publik. Beberapa aplikasi membutuhan akses ini. Teknik ini diolah secara kreatif dengan cara menggabungkan sumber informasi yang ada dengan berbagai sumber lainnya untuk dapat memuaskan pengguna. Perintah ini dikembalikan dalam format JSON, memerlukan otentikasi \textit{user context}, dan frekuensi pemakaiannya dibatasi. Parameter GET \textit{statuses/firehose} dapat dilihat pada tabel \ref{table:ParameterGetStatusesFirehose}


\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
\textit{count} & Kumpulan pesan untuk dijadikan bahan materi \\ \hline
\textit{delimited}          & Menentukan apakah pesan harus dibatasi limitnya. \\ \hline
\textit{stall\_warning}           & Menentukan apakah pesan warning harus dikirim atau tidak.                \\     \hline        
\end{tabular}
\caption{Parameter GET \textit{statuses/firehose}}
\label{table:ParameterGetStatusesFirehose}
\end{table}


\paragraph{Menggunakan \textit{Streaming} API}
Proses menggunakan \textit{streaming} API adalah dengan cara menghubungkan \textit{endpoint} yang sudah tercantum di atas dengan parameter yang sudah di-\textit{list} kepada \textit{streaming endpoint} dan juga \textit{request} parameter \textit{streaming} API.

\paragraph{Koneksi}
Setiap akun hanya dapat membuat satu koneksi yang terhubung dengan \textit{public endpoint} dan jika melakukan koneksi ke \textit{public stream} lebih dari satu kali dengan menggunakan akun yang sama akan menyebabkan koneksi terlama akan putus. Klien yang membuat koneksi secara berlebihan baik berhasil ataupun tidak maka IP mereka otomatis akan di \textit{banned}.

%User Streams
\paragraph{\textit{User Streams}}
\textit{User Stream} memberikan aliran(\textit{stream}) data dan event yang spesifik untuk akun yang sudah diotentikasi. Perintah ini dikembalikan dalam format JSON, memerlukan otentikasi \textit{user context}, dan frekuensi pemakaiannya dibatasi. Parameter untuk parameter ini dapat dilihat pada tabel \ref{table:ParameterGetUser}


\paragraph{\textit{Endpoints}}
\begin{itemize}
	\item GET \textit{user}
\end{itemize}

\begin{table}[h]
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\textit{delimited}              & Menentukan apakah pesan harus dibatasi limitnya.																												\\ \hline
\textit{stall\_warnings}        & Menentukan apakah pesan \textit{warning} harus dikirim atau tidak.                                                               \\ \hline
\textit{with}                   & Menentukan apakah pesan informasi harus dikembalikan kepada akun yang sudah diotentikasi atau dilakukan pengiriman juga kepada akun yang di-\textit{follow} oleh akun yang sudah diotentikasi tersebut.\\ \hline
\textit{replies}                & Menentukan apakah harus mengembalikan @replies.                                                                             \\ \hline
\textit{follow}                 & Termasuk \textit{tweet publik} tambahan dari daftar yang disediakan untuk ID pengguna.														\\ \hline
\textit{track}                  & Termasuk \textit{tweet} tambahan yang cocok dengan kata kunci tertentu.     \\ \hline
\textit{locations}              & Termasuk \textit{tweet} tambahan yang termasuk dalam batasan lokasi tertentu.                                                      \\ \hline
\textit{stringify\_friend\_ids} & Mengirim list teman yang terdiri dari \textit{array of integer} dan \textit{array of string}.              \\ \hline            
\end{tabular}
\caption{Parameter GET \textit{user}}
\label{table:ParameterGetUser}
\end{table}

\paragraph{Koneksi}
Jika suatu perangkat lunak menggunakan \textit{user stream}, maka sebisa mungkin untuk meminimalkan jumlah koneksi suatu perangkat lunak. Setiap akun Twitter terbatas hanya untuk beberapa koneksi \textit{user stream} per otentikasi perangkat lunak, terlepas dari IP(\textit{Internet Protocol}). Setelah mencapai batasnya, maka koneksi tertua atau terlama akan diberhentikan secara otomatis. \textit{User} \textit{login} dari beberapa instansi dari otentikasi perangkat lunak yang sama akan mengalami siklus koneksi yaitu akan dihubungan dan diputuskan satu sama lain.

Sebuah aplikasi harus dapat mengatasi HTTP(\textit{The Hypertext Transfer Protocol}) 420 \textit{error code} yang memberitahukan bahwa suatu akun sudah terlalu sering melakukan \textit{login}. Oleh karena itu, akun yang seperti itu akan secara otomatis di-\textit{banned} dari \textit{user stream} untuk tingkat \textit{login} yang berlebihan. Perhatikan bahwa setiap perangkat lunak memiliki alokasinya masing-masing, sehingga \textit{login} dari perangkat lunak yang pertama tidak akan mempengaruhi koneksi untuk perangkat lunak yang kedua, begitu juga sebaliknya. Tetapi akan menimbulkan masalah apabila menjalankan terlalu banyak salinan perangkat lunak yang pertama maupun kedua. Jika anda perlu membuat koneksi atas nama beberapa akun dari perangkat lunak yang sama, maka akan lebih baik jika menggunakan \textit{site stream}.

%OAuth
\section{OAuth}
\label{sec:oauth}
Dengan semakin berkembangnya \textit{website}, semakin banyak situs yang bergantung pada layanan distribusi dan \textit{cloud computing}. Contohnya adalah menggunakan jejaring sosial dengan menggunakan akun media sosial lainnya seperti Google untuk mencari teman-teman yang sudah tersimpan pada kontak Google. Atau bisa juga menggunakan pihak ketiga yang memanfaatkan API dari beberapa layanan.

OAuth menyediakan suatu metode bagi pengguna untuk memberi akses pihak ketiga untuk \textit{resources} (sumber daya) mereka tanpa berbagi \textit{password}. Sebagai contoh, seorang pengguna \textit{website} dapat memberikan layanan percetakan untuk mengakses foto pribadinya yang disimpan di layanan berbagi foto tanpa harus memberikan \textit{username} dan \textit{password}nya. Ia akan mengotentikasi langsung dengan layanan berbagi foto tersebut sehingga dapat dibagikan kepada layanan percetakan.

Agar \textit{client} dapat mengakses \textit{resource} mereka, pertama-tama ia harus mendapatkan izin dari si pemilik \textit{resource}. Izin ini dinyatakan dalam bentuk token dan juga digunakan untuk mencocokkan \textit{shared-secret}. Tujuan dari token ini adalah untuk membuat pemilik \textit{resource} berbagi kepercayaan mereka kepada \textit{client}. Token dapat dikeluarkan dalam ruang lingkup terbatas, durasi yang terbatas, dan akan dicabut secara independen\footnote{Hueniverse Documentation , OAuth, \url{http://hueniverse.com/oauth/guide/intro/}, pada tanggal 20 Agustus 2014 pukul 12.58}.

\paragraph{Twitter OAuth}yang diberikan memiliki fitur :
\begin{itemize}
	\item \textit{Secure}
	
	Pengguna tidak harus berbagi \textit{password} mereka dengan aplikasi pihak ketiga untuk meningkatkan keamanan akun.
	\item \textit{Standard}
	
	Banyak \textit{library} dan contoh kode yang tersedia dengan implementasi Twitter Oauth.
\end{itemize}

\subsection{\textit{Application-only authentication}}
Twitter menawarkan aplikasi yang mampu mengeluarkan permintaan otentikasi atas nama aplikasi itu sendiri. Dengan menggunakan \textit{application-only authentication}, perangkat lunak tidak mempunyai konteks dari otentikasi pengguna dan ini berarti setiap \textit{request} API untuk endpoint akan membutuhkan konteks pengguna, seperti memposting \textit{tweet} tidak akan bekerja. \textit{Application-only authentication} dapat melakukan berbagai macam aktivitas, seperti : 

\begin{itemize}
	\item melihat \textit{timeline}, 
	\item mengakses \textit{following} dan \textit{follower} dari suatu \textit{akun},
	\item mencari \textit{tweet},
	\item mengambil informasi dari akun Twitter manapun.
\end{itemize}


Tetapi \textit{application-only authentication} tidak dapat melakukan :

\begin{itemize}
	\item Posting \textit{tweet}
	\item Melakukan koneksi dengan \textit{Streaming endpoint}
	\item Mencari akun seseorang
	\item Menggunakan \textit{geo endpoint}
	\item Mengakses \textit{Direct Message}
\end{itemize}

\paragraph{\textit{OAuth Flow}}
Langkah-langkah dari \textit{application-only auth} terdiri dari :
Sebuah aplikasi dikodekan berdasarkan \textit{consumer key} dan \textit{secret} ke dalam satu set khusus yang dikodekan secara kredensial.
aplikasi membuat \textit{request} kepada POST OAuth2/\textit{token endpoint} untuk mengubah kredensial tersebut menjadi \textit{token bearer}.
Ketika mengakses REST API, aplikasi menggunakan \textit{token bearer} untuk melakukan otentikasi.

\paragraph{Tentang \textit{Application-only Authentication}}
Token adalah \textit{password}. \textit{Consumer key} dan \textit{secret, bearer token credential}, dan \textit{the bearer token} memberikan akses untuk membuat permintaan atas nama aplikasi itu sendiri. Poin-poin ini harus dianggap sensitif layaknya \textit{password} dan tidak boleh dibagikan atau didistribusikan kepada pihak yang tidak dipercaya atau tidak berkepentingan.

\textit{SSL}(\textit{Secure Sockets Layer}) sangat dibutuhkan karena \textit{SSL} merupakan cara otentikasi yang aman. Oleh karena itu, semua \textit{request} (baik untuk mendapatkan atau menggunakan token) harus menggunakan \textit{endpoint} HTTPS, yang juga merupakan syarat untuk menggunakan API.

\textit{Request} yang dibuat atas nama pengguna tidak akan menguras ketersediaan \textit{rate limit}, begitu juga dengan \textit{request}. Request tidak akan menguras batas penggunaan \textit{limit} dalam \textit{user-based auth}.


\subsection{3-\textit{legged authorization}}
Tahap awal dari cara kerja dari \textit{3-legged authorization} adalah dengan memberikan \textit{access token}. Pengambilan \textit{access token} dilakukan dengan cara melakukan \textit{redirect} akun dengan Twitter. Lalu Twitter memberikan akun sebuah otentikasi dari aplikasi yang telah dibuat. Terdapat dua pengecualian dalam cara kerja dari \textit{3-legged authorization}, yaitu :

\begin{itemize}
	\item GET \textit{oauth endpoint} digunakan sebagai pengganti GET \textit{oauth},
	\item akun akan selalu diminta untuk mengotentikasi perangkat lunak.
\end{itemize}

\subsection{\textit{PIN-based authorization}}
\textit{PIN-based authorization} ditujukan untuk perangkat lunak yang tidak bisa mengakses atau menanamkan \textit{web browser} untuk mengarahkan akun kepada \textit{authorization endpoint}. Contohnya adalah perangkat lunak yang bersifat \textit{command-line}, \textit{embedded systems}, \textit{game} konsol, dan beberapa jenis aplikasi \textit{mobile}.


\paragraph{Implementasi}

Implementasi \textit{PIN-based authorization} ini memiliki cara kerja yang sama seperti \textit{3-legged authorization}. Perbedaan antara \textit{PIN-based authorization} dengan 3-\textit{legged authorization} terletak pada nilai dari \textit{oauth\_callback} yang harus di-set menjadi \textit{oob} saat proses pemanggilan \textit{POST oauth} atau \textit{request\_token}.

Setelah perangkat lunak telah mendapatkan \textit{GET oauth/authenticate} atau \textit{GET oauth/authorize URL}, aplikasi akan memberi URL kepada pengguna. URL tersebut dimasukkan oleh pengguna menggunakan \textit{web browser} untuk mengakses URL tersebut.

Ketika \textit{callback oob} diminta, pengguna tidak akan dipindahkan secara otomatis ke perangkat lunak setelah menyetujui akses seperti yang dilakukan 3-\textit{legged authorization}. Akan tetapi jika menggunakan \textit{PIN-based authorization}, pengguna akan melihat kode PIN untuk dikembalikan kepada perangkat lunak dengan cara memasukkan nilai dari kode PIN yang sudah diberikan. Gambar ~\ref{fig:pin} merupakan contoh nilai kode yang diberikan.

\begin{figure}[H]
\centering
\includegraphics{Gambar/pin.png}
\caption{Contoh PIN-based authorization}
	\label{fig:pin}
\end{figure}

Perangkat lunak harus dirancang agar memungkinkan pengguna untuk memasukkan \textit{PIN code}. Nilai dari \textit{PIN code} harus lolos sebagai \textit{oauth\_verifier} untuk \textit{POST oauth/access\_token request}. Semua \textit{request} akan berjalan normal kedepannya.


%\section{KIRI}
%\label{sec:kiri}
%KIRI adalah sebuah situs atau \textit{website} yang memberi panduan tentang jalur transportasi publik. Alasan KIRI dapat berdiri adalah karenanya global warming, kemacetan, harga bensin yang semakin mahal. Ketiga alasan tersebut yang menjadi masalah sekarang ini, dan semua itu dapat diatasi dengan menaiki transportasi publik. 

%Peran dari KIRI ini adalah memberitahukan seseorang jalur transportasi publik dari satu tempat ke tempat yang dituju. Adapula format yang harus diisi dalam melakukan pencarian ini yaitu
%\begin{enumerate}
%	\item kota,
%	\item tempat awal,
%	\item tempat tujuan.
%\end{enumerate}

\section{KIRI API}
KIRI API adalah aplikasi pihak ketiga yang memungkinkan pengembang perangkat lunak mendapatkan data tentang info jalur transportasi publik. Semua \textit{request} harus berisi API \textit{key} yang dapat diambil melalui KIRI API \textit{Management Dashboard}. Berikut adalah spesifikasi dari KIRI API :

\begin{itemize}
	\item \textit{Routing Web Service}
	\item \textit{Search Place Web Service}
	\item \textit{Nearest Transports Web Service}
\end{itemize}

\subsection{\textit{Routing Web Service}}
\textit{Routing Web Service} adalah salah satu KIRI API yang digunakan untuk mendapatkan langkah perjalanan dari lokasi awal menuju lokasi tujuan.

Berikut ini adalah parameter \textit{request} yang diperlukan:

\begin{table}[h]
\begin{tabular}{ |p{3cm}|p{3cm}|p{8cm}| }
	\hline
	\textit{Parameter} & \textit{Valid values} & \textit{Description} \\ \hline \hline
  \textit{version} & 2 & Memberitahukan bahwa layanan yang dipakai adalah protokol versi 2 \\ \hline
  \textit{mode} & "\textit{findroute}" & Menginstruksikan layanan untuk mencari rute \\ \hline
  \textit{locale} & "en" or "id" & Respons bahasa yang digunakan \\ \hline
	\textit{start} & lat,lng (\textit{both are decimal values}) & Titik awal \textit{Latitude} dan \textit{longitude} \\ \hline
  \textit{finish} & lat,lng (\textit{both are decimal value}s) & Titik akhir \textit{Latitude} dan \textit{longitude}  \\ \hline
  \textit{presentation} & "\textit{mobile}" or "\textit{desktop}" & Menentukan tipe presentasi untuk hasil keluaran. \\ \hline
	\textit{apikey} & 16-digit \textit{hexadecimals} & API \textit{key} yang digunakan \\ \hline
\end{tabular}
	\caption{Parameter \textit{Routing Web Service}}
	\label{tab:TabelParameterRoutingWebService}
	\end{table}
	
\begin{lstlisting} [caption= {kode respon pencarian rute},label={lst:codeResponPencarianRute}]
{ 
    "status": "ok" or "error" 
    "routingresults": [ 
        {
            "steps": [
                [
                    "walk" or "none" or others,
                    "walk" or vehicle_id or "none",
                    ["lat_1,lon_1", "lan_2,lon_2", ... "lat_n,lon_n"],
                    "human readable description, dependant on locale",
                    URL for ticket booking or null (future)
                ],
                [
                    "walk" or "none" or others,
                    "walk" or vehicle_id or "none",
                    ["lat_1,lon_1", "lan_2,lon_2", ... "lat_n,lon_n"],
                    "human readable description, dependant on locale",
                    URL for ticket booking or null (future)
                ]
            ],
            "traveltime": any text string, null if and only if route is not found.
        } ,
        {
            "steps": [ ... ],
            "traveltime": "..."
        } ,
        {
            "steps": [ ... ],
            "traveltime": "..."
        } ,
        ...     
    ]
}
\end{lstlisting}

Listing ~\ref{lst:codeResponPencarianRute} menunjukan hasil yang akan diberikan dari pencarian rute. Ketika pencarian rute berhasil, maka status yang diberikan akan bernilai "ok" seperti pada baris 2. Kemudian server harus memberikan hasil dari rute yang berisi langkah-langkah yang disimpan di dalam \textit{array}. Berikut ini adalah keterangan dari \textit{array} tersebut:

\begin{itemize}
	\item \textit{Index} 0 berisikan "\textit{walk}" atau "\textit{none}" atau "\textit{others}". "\textit{Walk}" berarti jalan kaki, "\textit{none}" berarti rute jalan tidak ditemukan, dan "\textit{others}" berarti menggunakan kendaraan.
	\item \textit{Index} ke 1 merupakan \textit{detail} dari \textit{index} ke 0 yang memiliki arti:
	\begin{itemize}
		\item Jika berisikan "\textit{walk}" berarti \textit{index} ini pun harus berisikan "\textit{walk}",
		\item Jika berisikan "\textit{none}" maka \textit{index} ini pun harus berisikan "\textit{none}",
		\item Selain itu, maka \textit{field} ini berisikan id kendaraan yang dapat digunakan untuk menampilkan gambar dari id kendaraan tersebut.
	\end{itemize}
	\item \textit{Index} ke 2 berisikan \textit{array of string}, yang berisikan jalur dalam format "lat,lon". Lat adalah \textit{latitude}, dan lon adalah \textit{longitude} yaitu titik awal dan titik akhir.
	\item \textit{Index} ke 3 merupakan bentuk yang dapat dibaca oleh manusia lalu akan ditampilkan kepada pengguna. Informasi tersebut dapat berupa:
	\begin{itemize}
		\item \%\textit{fromicon} = sebuah \textit{icon} penanda yang menunjukkan titik awal atau "\textit{from}". Biasanya digunakan untuk mode presentasi perangkat bergerak.
		\item \%\textit{toicon} = sebuah \textit{icon} penanda yang menunjukkan titik akhir atau "\textit{to}". Biasanya digunakan untuk mode presentasi perangkat bergerak.
	\end{itemize}
	\item \textit{Index} ke 4 berisi URL untuk pemesanan tiket untuk travel jika tersedia. Jika tidak ada maka nilai dari \textit{index} ini bernilai null.
\end{itemize}


\subsection{\textit{Search Place Web Service}}
\textit{Search Place Web Service} berguna untuk menemukan rute perjalanan berdasarkan \textit{latitute} dan \textit{longitude} koordinat. Layanan \textit{Search Place Web Service} ini membantu mengubah string teks untuk \textit{latitude} dan \textit{longitude}. Untuk dapat melakukan permintaan rute, berikut parameter \textit{request} yang diperlukan:

\begin{table}[h]
\begin{tabular}{ |l |l |l| }
	\hline
  \textit{version} & 2 & \vtop{\hbox{\strut Memberitahukan bahwa layanan yang dipakai} \hbox{\strut adalah protokol versi 2}} \\ \hline
  \textit{mode} & "\textit{searchplace}" & menginstruksikan layanan untuk mencari tempat \\ \hline
  \textit{region} & "cgk" or "bdo" or "sub" & kota yang akan dicari tempatnya \\ \hline
	\textit{querystring} & \vtop{\hbox{\strut text apa saja dengan minimum} \hbox{\strut text satu karakter}} & \vtop{\hbox{\strut \textit{query string} yang akan dicari menggunakan}  \hbox{\strut layanan ini}} \\ \hline
	\textit{apikey} & 16-digit \textit{hexadecimals} & API \textit{key} yang digunakan \\ \hline
\end{tabular}
\caption{Tabel parameter \textit{Search Place Web Service}}
	\label{tab:TabelParameterSeachPlaceWebService}
\end{table}

Berikut format kembalian dari KIRI API:
\begin{lstlisting} [caption= code \textit{respond} pencarian lokasi]
{
    "status": "ok" or "error"
    "searchresult": [
        {
            "placename": "place name"
            "location": "lat,lon"
        },
        {
            "placename": "place name"
            "location": "lat,lon"
        },
        ...
    ]
    "attributions": [
        "attribution_1", "attribution_2", ...
    ]
}
\end{lstlisting}

Ketika \textit{request find place} berhasil, \textit{server} akan mengembalikan \textit{place result}. Hasil dari \textit{place result} merupakan \textit{array} dari langkah-langkah perjalanan, berikut adalah contoh dari hasil \textit{place result}:
\begin{itemize}
	\item \textit{searchresult} - berisi \textit{array} dari hasil objek:
	\begin{itemize}
		\item \textit{placename} - nama dari suatu tempat
		\item \textit{location} : \textit{latitude} dan \textit{longitude} dari suatu tempat
	\end{itemize}
	\item \textit{attributions} - berisi \textit{array string} dan atribut tambahan yang akan ditampilkan
\end{itemize}

\subsection{\textit{Nearest Transports Web Service}}
\textit{Nearest Transports Web Service} digunakan untuk menemukan rute transportasi terdekat dengan titik yang diberikan.

Berikut parameter \textit{request} yang diperlukan berikut penjelasanya:
\begin{table}[h]
\begin{tabular}{ |l |l |l| }
	\hline
  \textit{version} & 2 & \vtop{\hbox{\strut Memberitahukan bahwa layanan yang dipakai} \hbox{\strut adalah protokol versi 2}} \\ \hline
  \textit{mode} & "\textit{nearbytransports}" & \vtop{\hbox{\strut menginstruksikan layanan untuk mencari rute} \hbox{\strut transportasi terdekat}} \\ \hline
  \textit{start} & \vtop{\hbox{\strut \textit{latitude} dan \textit{longitude}} \hbox{\strut (keduanya menggunakan nilai desimal)}} & kota yang akan dicari tempatnya \\ \hline
	\textit{apikey} & 16-digit \textit{hexadecimals} & API \textit{key} yang digunakan \\ \hline
\end{tabular}
\caption{Tabel parameter \textit{Nearest Transports Web Service}}
	\label{tab:TabelParameterNearestTransportWebService}
\end{table}


Berikut format kembalian dari KIRI API:

\begin{lstlisting} [caption= code \textit{respond} menemukan lokasi terdekat]
{
    "status": "ok" or "error"
    "nearbytransports": [
        [
            "walk" or "none" or others,
            "walk" or vehicle_id or "none",
            text string,
            decimal value
        ],
        [
            "walk" or "none" or others,
            "walk" or vehicle_id or "none",
            text string,
            decimal value
        ],
        ...     
    ]
}\end{lstlisting}

Pencarian akan memberitahukan status berhasil ("\textit{ok}") atau tidak ("\textit{error}"). Ketika pencarian sukses, maka respon akan mengembalikan array yang berisikan transportasi terdekat yang diurutkan dari yang paling dekat ke yang paling jauh. Berikut keterangan dari setiap \textit{array} tersebut: 
\begin{itemize}
	\item \textit{Index} ke 0 dapat berisi "\textit{walk}" atau "\textit{none}" atau "\textit{others}". Artinya  jika isi dari \textit{array} tersebut "\textit{walk}" berarti berjalan kaki, "\textit{none}" jika rute tidak ditemukan dan "\textit{others}" berarti menggunakan kendaraan.
	\item \textit{Index} ke 1 merupakan detail dari \textit{index} 0. Artinya jika \textit{index} 0 "\textit{walk}" berarti \textit{index} 1 harus "\textit{walk}", "\textit{none}" berarti \textit{index} 1 harus "\textit{none}" dan selain itu menyatakan id kendaraan yang mana bisa dipakai untuk ditampilkan gambarnya.
	\item \textit{Index} ke 2 berisi nama kendaraan yang dapat dibaca oleh pengguna.
	\item \textit{Index} ke 3 berisi jarak dalam satuan kilometer.
\end{itemize}

\section{Twitter4J}
Twitter4J merupakan \textit{Java Library} untuk Twitter API. Dengan adanya Twitter4J ini, kita dapat dengan mudah mengintegrasikan aplikasi Java dengan Twitter \textit{service}. Twitter4J memiliki fitur-fitur sebagai berikut :

\begin{itemize}
	\item 100\% menggunakan Bahasa Java.
	\item Tersedia untuk \textit{Android platform} dan \textit{Google App Engine}.
	\item Tidak adanya dependensi, tidak memerlukan \textit{jar} tambahan.
	\item Mendukung sistem OAuth.
	\item Kompatibel dengan Twitter API 1.1
\end{itemize}

Dalam pembuatan aplikasi yang akan penulis buat, penulis membutuhkan beberapa \textit{library} yang telah diberikan oleh Twitter4J. Berikut adalah \textit{library} yang diberikan Twitter4J :
\subsection{Twitter}
	
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public interface Twitter
extends java.io.Serializable, OAuthSupport, OAuth2Support, TwitterBase, TimelinesResources, TweetsResources, SearchResource, DirectMessagesResources, FriendsFollowersResources, UsersResources, SuggestedUsersResources, FavoritesResources, ListsResources, SavedSearchesResources, PlacesGeoResources, TrendsResources, SpamReportingResource, HelpResources
			
		\end{itemize}
		
		\item \textit{Methods}
		
		\begin{itemize}
			\item TimelinesResources timelines()
			\item TweetsResources tweets()
			\item SearchResource search()
			\item DirectMessagesResources directMessages()
			\item FriendsFollowersResources friendsFollowers()
			\item UsersResources users()
			\item SuggestedUsersResources suggestedUsers()
			\item FavoritesResources favorites()
			\item ListsResources list()
			\item SavedSearchesResources savedSearches()
			\item PlacesGeoResources placesGeo()
			\item TrendsResources trends()
			\item SpamReportingResource spamReporting()
			\item HelpResources help()
		\end{itemize}
		\textit{Tidak ada penjelasan yang diberikan oleh Twitter4J}
	\end{itemize}
	
\subsection{TwitterFactory}
	
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public final class TwitterFactory
			extends java.lang.Object
			implements java.io.Serializable
			
			Sebuah \textit{factory class} untuk Twitter
		\end{itemize}
		\item \textit{Constructor}
		
		\begin{itemize}
			\item TwitterFactory()
			
			Membuat TwitterFactory dengan konfigurasi dari sumber.
			\item TwitterFactory(Configuration conf)
			
			Membuat TwitterFactory dengan konfigurasi yang diberikan.
			\item TwitterFactory(java.lang.String configTreePath)
			
			Membuat TwitterFactory yang berasal dari \textit{config tree} yang spesifik.
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item public Twitter getInstance()
			
			mengembalikan contoh yang terkait dengan konfigurasi.
			\item public Twitter getInstance(AccessToken accessToken)
			
			mengembalikan OAuth yang sudah otentikasi.
			\item public Twitter getInstance(Authorization auth)
			\item public static Twitter getSingleton()
			
			Mengembalikan \textit{singleton} standar Twitter \textit{instance}.
		\end{itemize}
	\end{itemize}
	
	
	\subsection{TwitterStream}
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public interface TwitterStream
			extends OAuthSupport, TwitterBase
			
			Sebuah \textit{factory class} untuk Twitter
		\end{itemize}
		
		\item \textit{Methods}
		
		\begin{itemize}
			\item void addConnectionLifeCycleListener(ConnectionLifeCycleListener listener)
			
			Menambahkan \textit{ConnectionLifeCycleListener}
			\item void addListener(StreamListener listener)
			
			Menambahkan listener.
			\item void removeListener(StreamListener listener)
			
			Menghilangkan listerner.
			\item void clearListeners()
			
			Menghilangkan \textit{status listener}.
			\item void replaceListener(StreamListener toBeRemoved,StreamListener toBeAdded)
			
			Menimpa listener yang sudah ada sebelumnya.
			\item void firehose(int count)
			
			Mendengarkan semua status publik.
			\item void links(int count)
			
			Mendengarkan semua status publik yang mengandung link.
			\item void retweet()
			
			Mendengarkan semua retweet.
			\item void sample()
			
			Mendengarkan status publik secara acak.
			\item void user()
			
			\textit{User Streams} menyediakan update dari semua data secara \textit{real-time}.
			\item void user(java.lang.String[] track)
			
			\textit{User Streams} menyediakan update dari semua data secara \textit{real-time}. Parameter track merupakan kata kunci untuk kata yang akan ditampilkan.
			\item StreamController site(boolean withFollowings, long[] follow)
			
			Menerima update secara \textit{real-time} untuk sejumlah pengguna tanpa perlu kerepotan dalam mengelola REST API \textit{rate limits}.
			\item void filter(FilterQuery query)
			
			Menerima status publik yang telah di \textit{filter} dari satu atau lebih kata kunci.
			\item void cleanUp()
			
			Menon-aktifkan penggunaan \textit{thread stream}.
			\item void shutdown()
			
			Menon aktifkan \textit{dispatcher thread} bersama dengan semua instansi TwitterStream.
		\end{itemize}
	\end{itemize}
	
	\subsection{TwitterStreamFactory}
	
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public final class TwitterStreamFactory
			extends java.lang.Object
			implements java.io.Serializable
			
			Sebuah \textit{factory class} untuk Twitter. Instansi dari kelas ini memiliki thread yang aman dan digunakan secara berkala lalu dapat digunakan kembali.
		\end{itemize}
		\item \textit{Constructor}
		
		\begin{itemize}
			\item TwitterStreamFactory()
			Membuat TwitterStreamFactory dengan konfigurasi dari sumber.
			\item TwitterStreamFactory(Configuration conf)
			Membuat TwitterStreamFactory dengan konfigurasi yang diberikan.
			\item TwitterStreamFactory(java.lang.String configTreePath)
			Membuat TwitterStreamFactory yang berasal dari \textit{config tree} yang spesifik.
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item public TwitterStream getInstance()
			
			Mengembalikan contoh yang terkait dengan konfigurasi.
			\item public TwitterStream getInstance(AccessToken accessToken)
			
			Mengembalikan OAuth yang sudah diotentikasi.
			\item public TwitterStream getInstance(Authorization auth)
			
			Mengembalikan \textit{instance}.
			\item private TwitterStream getInstance(Configuration conf, Authorization auth)
			
			Mengembalikan \textit{instance} dengan konfigurasi dan autorisasi yang sesuai.
			\item public static Twitter getSingleton()
			
			Mengembalikan \textit{singleton} standar Twitter \textit{instance}.
		\end{itemize}
	\end{itemize}
	
	\subsection{UserStreamListener}
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public interface UserStreamListener
			extends StatusListener
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item void onDeletionNotice(long directMessageId, long userId)
			\item void onFriendList(long[] friendIds)
			\item void onFavorite(User source, User target, Status favoritedStatus)
			\item void onUnfavorite(User source, User target, Status unfavoritedStatus)
			\item void onFollow(User source, User followedUser)
			\item void onUnfollow(User source, User unfollowedUser)
			\item void onDirectMessage(DirectMessage directMessage)
			\item void onUserListMemberAddition(User addedMember, User listOwner, UserList list)
			\item void onUserListMemberDeletion(User deletedMember, User listOwner, UserList list)
			\item void onUserListSubscription(User subscriber, User listOwner, UserList list)
			\item void onUserListUnsubscription(User subscriber, User listOwner, UserList list)
			\item void onUserListCreation(User listOwner, UserList list)
			\item void onUserListUpdate(User listOwner, UserList list)
			\item void onUserListDeletion(User listOwner, UserList list)
			\item void onUserProfileUpdate(User updatedUser)
			\item void onBlock(User source, User blockedUser)
			\item void onUnblock(User source, User unblockedUser)
		\end{itemize}
	\textit{Tidak ada penjelasan yang diberikan oleh Twitter4J}
	\end{itemize}
	
	\subsection{StatusListener}
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public interface StatusListener
			extends StreamListener
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item void onStatus(Status status)
			\item void onDeletionNotice(StatusDeletionNotice statusDeletionNotice)
			
			Method untuk memberitahukan notifikasi deletionNotice.
			\item void onTrackLimitationNotice(int numberOfLimitedStatuses)
			
			Method untuk memberitahukan bahwa predikat terlalu luas.
			\item void onScrubGeo(long userId, long upToStatusId)
			
			Method untuk memberitahukan \textit{location deletion}.
			\item void onStallWarning(StallWarning warning)
			
			Method untuk memberitahukan pesan \textit{warning}.
			\item 
		\end{itemize}
	\end{itemize}
	
	\subsection{StatusUpdate}
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public final class StatusUpdate
			extends java.lang.Object
			implements java.io.Serializable
		\end{itemize}
		
		\item \textit{Field}
		
		\begin{itemize}
			\item private boolean displayCoordinates
			\item private long inReplyToStatusId 
			\item private GeoLocation location 
			\item private java.io.InputStream mediaBody 
			\item private java.io.File mediaFile 
			\item private long[] mediaIds 
			\item private java.lang.String mediaName 
			\item private java.lang.String placeId 
			\item private boolean possiblySensitive 
			\item private static long serialVersionUID 
			\item private java.lang.String status 
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item private void appendParameter(java.lang.String name, double value, java.util.List<HttpParameter> params) 
			\item private void appendParameter(java.lang.String name, long value, java.util.List<HttpParameter> params) 
			\item private void appendParameter(java.lang.String name, java.lang.String value, java.util.List<HttpParameter> params) 
			\item (package private) HttpParameter[] asHttpParameterArray() 
			\item StatusUpdate displayCoordinates(boolean displayCoordinates) 
			\item boolean equals(java.lang.Object o) 
			\item long getInReplyToStatusId() 
			\item GeoLocation getLocation() 
			\item java.lang.String getPlaceId() 
			\item java.lang.String getStatus() 
			\item int hashCode() 
			\item StatusUpdate inReplyToStatusId(long inReplyToStatusId) 
			\item boolean isDisplayCoordinates() 
			\item (package private) boolean isForUpdateWithMedia() 
			\item boolean isPossiblySensitive() 
			\item StatusUpdate location(GeoLocation location) 
			\item StatusUpdate media(java.io.File file) 
			\item StatusUpdate media(java.lang.String name, java.io.InputStream body) 
			\item StatusUpdate placeId(java.lang.String placeId) 
			\item StatusUpdate possiblySensitive(boolean possiblySensitive) 
			\item void setDisplayCoordinates(boolean displayCoordinates) 
			\item void setInReplyToStatusId(long inReplyToStatusId) 
			\item void setLocation(GeoLocation location) 
			\item void setMedia(java.io.File file) 
			\item void setMedia(java.lang.String name, java.io.InputStream body) 
			\item void setMediaIds(long[] mediaIds) 
			\item void setPlaceId(java.lang.String placeId) 
			\item void setPossiblySensitive(boolean possiblySensitive) 
			\item java.lang.String 	toString() 
		\end{itemize}
	\textit{Tidak ada penjelasan yang diberikan oleh Twitter4J}
	\end{itemize}
	
	\subsection{TweetsResources}
	\begin{itemize}
		\item \textit{Constant}
		
			\begin{itemize}
				\item public interface TweetsResources
			\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item ResponseList<Status> getRetweets(long statusId) throws TwitterException
			
			Mengembalikan sampai dengan 100 retweet pertama yang diberikan.
			\item IDs getRetweeterIds(long statusId, long cursor) throws TwitterException
			
			Mengembalikan sampai dengan 100 ID pengguna yang telah melakukan retweet oleh parameter ID tertentu
			\item IDs getRetweeterIds(long statusId, int count, long cursor) throws TwitterException
			
			Mengembalikan sampai dengan "\textit{count}" ID pengguna yang telah melakukan retweet oleh parameter ID tertentu
			\item Status showStatus(long id) throws TwitterException
			
			Mengembalikan \textit{single status} yang ditentukan oleh parameter ID yang telah ditentukan.
			\item Status destroyStatus(long statusId) throws TwitterException
			
			Menghapus status yang ditentukan oleh parameter ID yang telah ditentukan.
			\item Status updateStatus(java.lang.String status) throws TwitterException
			
			Melakukan update status oleh user yang telah diotentikasi
			\item Status updateStatus(StatusUpdate latestStatus) throws TwitterException
			
			Melakukan update status oleh user yang telah diotentikasi.
			\item Status retweetStatus(long statusId) throws TwitterException
			
			Melakukan retweet.
			\item OEmbed getOEmbed(OEmbedRequest req) throws TwitterException
			Mengembalikan informasi yang dapat merepresentasikan \textit{third party} Tweet
			
			\item ResponseList<Status> lookup(long[] ids) throws TwitterException
			
			Mengembalikan \textit{fully-hydrated tweet objects} sampai dengan 100 tweet setiap \textit{request}nya.
			\item UploadedMedia uploadMedia(java.io.File mediaFile) throws TwitterException
			
			Melakukan \textit{upload} media gambar yang telah di dilampirkan via updateStatus(twitter4j.StatusUpdate)
		\end{itemize}
	\end{itemize}

	\subsection{OAuthSupport}
	\begin{itemize}
		\item \textit{Constant}
		
			\begin{itemize}
				\item public interface OAuthSupport
			\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item void setOAuthConsumer(java.lang.String consumerKey, java.lang.String consumerSecret)
			
			Melakukan pengaturan terhadap \textit{consumer key} dan \textit{consumer secret }.
			\item RequestToken getOAuthRequestToken() throws TwitterException
			
			Mengambil \textit{request token}.
			\item RequestToken getOAuthRequestToken(java.lang.String callbackURL) throws TwitterException
			
			
			Mengambil \textit{request token}.
			\item RequestToken getOAuthRequestToken(java.lang.String callbackURL, java.lang.String xAuthAccessType) throws TwitterException
			
			Mengambil \textit{request token}.
			\item AccessToken getOAuthAccessToken() throws TwitterException
			
			Mengembalikan \textit{access token} yang terkait dengan instansi ini. Jika tidak ada instansi pada \textit{access token} maka akan mengambil \textit{access token} yang baru.
			\item AccessToken getOAuthAccessToken(java.lang.String oauthVerifier) throws TwitterException
			
			Mengambil \textit{request token}.
			\item AccessToken getOAuthAccessToken(RequestToken requestToken) throws TwitterException
			
			Mengambil \textit{access token} yang terkait dengan \textit{request token }dan \textit{userId} yang telah diberikan
			\item AccessToken getOAuthAccessToken(RequestToken requestToken, java.lang.String oauthVerifier) throws TwitterException
			
			Mengambil \textit{access token} yang terkait dengan \textit{request token }dan \textit{userId} yang telah diberikan
			\item AccessToken getOAuthAccessToken(java.lang.String screenName, java.lang.String password) throws TwitterException
			
			Mengambil \textit{access token} yang terkait dengan \textit{screen name}dan \textit{password} yang telah diberikan
			\item void setOAuthAccessToken(AccessToken accessToken)
			
			Melakukan pengaturan pada \textit{access token}
		\end{itemize}
	\end{itemize}

\subsection{RequestToken}
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public final class RequestToken
			extends OAuthToken
			implements java.io.Serializable
			
		\end{itemize}
		\item \textit{Constructor}
		
		\begin{itemize}
			\item RequestToken(HttpResponse res, OAuthSupport oauth) 
			\item RequestToken(java.lang.String token, java.lang.String tokenSecret)
			\item RequestToken(java.lang.String token, java.lang.String tokenSecret, OAuthSupport oauth) 
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item public java.lang.String getAuthorizationURL()
			\item public java.lang.String getAuthenticationURL()
		\end{itemize}
	\end{itemize}
	
\subsection{AccessToken}
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public class AccessToken
			extends OAuthToken
			implements java.io.Serializable
						
		\end{itemize}
		\item \textit{Constructor}
		
		\begin{itemize}
			\item AccessToken(HttpResponse res) 
			\item AccessToken(java.lang.String token, java.lang.String tokenSecret) 
			\item AccessToken(java.lang.String token, java.lang.String tokenSecret, long userId) 
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item public java.lang.String getScreenName()
			
			Mengembalikan \textit{screen name}
			\item public long getUserId()
			
			Mengembalikan \textit{user id}
			\item public boolean equals(java.lang.Object o)
			\item public int hashCode()
			\item public java.lang.String toString()
		\end{itemize}
	\end{itemize}
	
	\subsection{Status}
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public interface Status
			extends java.lang.Comparable<Status>, TwitterResponse, EntitySupport, java.io.Serializable
						
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item java.util.Date getCreatedAts()
			
			Mengembalikan \textit{created\_at}
			\item public long getUserId()
			
			Mengembalikan \textit{user id}
			\item java.lang.String getText()
			
			Mengembalikan teks dari status
			\item java.lang.String getSource()
			
			Mengembalikan \textit{source}
			\item boolean isTruncated()
			
			Menguji apakah sebuah status terpotong atau tidak
			\item long getInReplyToStatusId()
			
			Mengembalikan \textit{in\_reply\_tostatus\_id}
			\item long getInReplyToUserId()
			
			Mengembalikan \textit{in\_reply\_user\_id}
			\item java.lang.String getInReplyToScreenName()
			
			Mengembalikan \textit{in\_reply\_to\_screen\_name}
			\item GeoLocation getGeoLocation()
			
			Mengembalikan lokasi dari suatu \textit{tweet} jika tersedia.
			\item Place getPlace()
			
			Mengembalikan tempat yang terdapat pada sebuah status.
			\item boolean isFavorited()
			
			Menguji apakah status tersebut \textit{favorite} atau tidak
			\item boolean isRetweeted()
			
			Menguji apakah status tersebut \textit{retweet} atau tidak
			\item int getFavoriteCount()
			
			Menunjukkan berapa kali Tweet telah menjadi \textit{favorite}
			\item User getUser()
			
			Mengembalikan \textit{user} yang terdapat pada sebuah status.
			\item boolean isRetweet()
			\item Status getRetweetedStatus()
			\item long[] getContributors()
			
			Mengembalikan array yang berisi kontributor atau mengembalikan \textit{null} jika tidak ada kontributor yang terkait dengan status ini
			\item int getRetweetCount()
			
			Menunjukkan berapa kali Tweet telah di \textit{retweet}, jika belum terdapat maka akan mengembalikan nilai -1
			\item boolean isRetweetedByMe()
			
			Mengembalikan nilai \textit{true} jika \textit{user} yang telah diotentikasi melakukan \textit{retweet} terhadap suatu \textit{tweet}, atau mengembalikan nilai \textit{false} jika tidak.
			\item long getCurrentUserRetweetId()
			
			Mengembalikan \textit{retweet id} sebuah \textit{tweet} dari \textit{user} yang telah diotentikasi, jika belum terdapat maka akan mengembalikan nilai -1L
			\item boolean isPossiblySensitive()
			
			Mengembalikan nilai \textit{true} jika pada status terdapat \textit{sensitive links}
			\item java.lang.String getLang()
			
			Mengembalikan \textit{lang} dari sebuah status teks jika tersedia
			\item Scopes getScopes()
			
			Mengembalikan target dari \textit{scopes} yang diaplikasikan kepada sebuah status.
		\end{itemize}
	\end{itemize}
	
	\subsection{TweetsResources}
	\begin{itemize}
		\item \textit{Constant}
		
		\begin{itemize}
			\item public interface TweetsResources
						
		\end{itemize}
		\item \textit{Methods}
		
		\begin{itemize}
			\item ResponseList<Status> getRetweets(long statusId) throws TwitterException
			
			Mengembalikan hingga dengan seratus \textit{retweet} pertama
			\item IDs getRetweeterIds(long statusId, long cursor) throws TwitterException
			
			Mengembalikan hingga dengan 100 \textit{user ID} yang melakukan \textit{retweet} terhadap \textit{tweet} ditentukan dari \textit{id parameter}
			\item IDs getRetweeterIds(long statusId, int count, long cursor) throws TwitterException
			
			Mengembalikan hingga dengan \textit{"count"} \textit{user ID} yang melakukan \textit{retweet} terhadap \textit{tweet} ditentukan dari \textit{id parameter}
			\item Status showStatus(long id) throws TwitterException
			
			Mengembalikan \textit{status} yang ditentukan dari parameter id.
			\item Status destroyStatus(long statusId) throws TwitterException
			
			Menghapus \textit{status} yang ditentukan dari parameter id.
			\item Status updateStatus(java.lang.String status) throws TwitterException
			
			Melakukan \textit{update status} terhadap \textit{user} yang telah diotentikasi.
			\item Status updateStatus(StatusUpdate latestStatus) throws TwitterException
			
			Melakukan \textit{update status} terhadap \textit{user} yang telah diotentikasi.
			\item Status retweetStatus(long statusId) throws TwitterException
			
			Melakukan \textit{retweet} terhadap sebuah \textit{tweet}.
			\item OEmbed getOEmbed(OEmbedRequest req) throws TwitterException
			
			Mengembalikan informasi yang mengizinkan terciptanya \textit{embedded representation} dari tweet yang berada di \textit{third party sites}
			\item ResponseList<Status> lookup(long[] ids) throws TwitterException
			
			Mengembalikan objek \textit{tweet} hingga dengan 100 \textit{tweet} per \textbf{request}.
			\item UploadedMedia uploadMedia(java.io.File mediaFile) throws TwitterException
			
			Melakukan \textit{upload} gambar.
		\end{itemize}
	\end{itemize}
%\subsection{Contoh Kode}
%Untuk menjalankan ini semua, anda harus mempunyai OAuth credential yang telah dikonfigurasi pada twitter4j.properties.

%\begin{itemize}
%	\item Melakukan Tweet
	
%	Anda dapat melakukan Tweet seperti "Selamat pagi" dengan menggunakan \textit{method} Twitter.updateStatus().
%	\begin{lstlisting} [caption= code untuk melakukan Tweet]
%	{
%			Twitter twitter = TwitterFactory.getSingleton();
%			Status status = twitter.updateStatus(latestStatus);
%			System.out.println("Successfully updated the status to [" + status.getText() + "].");
%	}\end{lstlisting}
%	\item Mendapatkan Timeline
%	
%	Berikut adalah contoh kode untuk mendapatkan \textit{timeline}
%	\begin{lstlisting} [caption= code untuk mendapatkan \textit{timeline}]
%	{
%			Twitter twitter = TwitterFactory.getSingleton();
%    List<Status> statuses = twitter.getHomeTimeline();
%    System.out.println("Showing home timeline.");
%    for (Status status : statuses) {
%        System.out.println(status.getUser().getName() + ":" +
%                           status.getText());
%    }
%	}\end{lstlisting}
%	\item Mengirim dan Menerima \textit{Direct Message}
%	
%	Anda dapat mengirim dan menerima \textit{direct message} dengan menggunakan \textit{method} Twitter.sendDirectMessage() atau Twitter.getDirectMessages(). Berikut adalah contoh kodenya.
%	\begin{lstlisting} [caption= code untuk mengirim \textit{direct message}]
%	{
%			 Twitter sender = TwitterFactory.getSingleton();
%    DirectMessage message = sender.sendDirectMessage(recipientId, message);
%    System.out.println("Sent: " message.getText() + " to @" + message.getRecipientScreenName());
%    }
%	}\end{lstlisting}
%	\item Mencari Tweet
%	
%	Mencari Tweet dapat dilakukan dengan menggunakan kelas \textit{query} atau dengan menggunakan method Twitter.seach(twitter4j.Query). Berikut adalah contoh kodenya
%	\begin{lstlisting} [caption= code untuk mencari Tweet]
%	{
%			 Twitter twitter = TwitterFactory.getSingleton();
%    Query query = new Query("source:twitter4j yusukey");
%    QueryResult result = twitter.search(query);
%    for (Status status : result.getTweets()) {
%        System.out.println("@" + status.getUser().getScreenName() + ":" + status.getText());
%    }
%    }
%	}\end{lstlisting}
%	\item OAuth support
%	
%	Dengan menggunakan skema OAuth authorization, sebuah aplikasi dapat mengakses akun user tanpa menggunakan userid dan password. Anda hanya perlu melakukan registrasi %pada aplikasi anda ke http://twitter.com/oauth\_clients/new untuk mendapatkan \textit{consumer key}, dan \textit{consumer secret } terlebih dahulu. \textit{Key / %secret pair} dapat di set menggunakan Twitter\#setOAuthConsumer() atau mengikuti petunjuk \textit{system properties}:
%	\begin{itemize}
%		\item Dtwitter4j.oauth.consumerKey=[consumer key]
%%		\item Dtwitter4j.oauth.consumerSecret=[consumer secret]
%	\end{itemize}
%	Anda tidak perlu memiliki izin untuk mengakses sebuah akun tetapi harus memiliki \textit{access token} dengan mengarahkan user ke URL \textit{authorization} sebagai %berikut:
%	\begin{lstlisting} [caption= code untuk mengarahkan user ke URL \textit{authorization}]
%	{
%			 public static void main(String args[]) throws Exception{
%    // The factory instance is re-useable and thread safe.
%    Twitter twitter = TwitterFactory.getSingleton();
%    twitter.setOAuthConsumer("[consumer key]", "[consumer secret]");
%    RequestToken requestToken = twitter.getOAuthRequestToken();
%    AccessToken accessToken = null;
%    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
%    while (null == accessToken) {
%      System.out.println("Open the following URL and grant access to your account:");
%      System.out.println(requestToken.getAuthorizationURL());
%      System.out.print("Enter the PIN(if aviailable) or just hit enter.[PIN]:");
%      String pin = br.readLine();
%      try{
%         if(pin.length() > 0){
%           accessToken = twitter.getOAuthAccessToken(requestToken, pin);
%         }else{
%           accessToken = twitter.getOAuthAccessToken();
%         }
%      } catch (TwitterException te) {
%        if(401 == te.getStatusCode()){
%          System.out.println("Unable to get the access token.");
%        }else{
%          te.printStackTrace();
%        }
%      }
%    }
%    //persist to the accessToken for future reference.
%    storeAccessToken(twitter.verifyCredentials().getId() , accessToken);
%    Status status = twitter.updateStatus(args[0]);
%    System.out.println("Successfully updated the status to [" + status.getText() + "].");
%    System.exit(0);
%  }
%  private static void storeAccessToken(int useId, AccessToken accessToken){
%    //store accessToken.getToken()
%    //store accessToken.getTokenSecret()
%  }
%    }
%	\end{lstlisting}
%	Setelah mendapatkan \textit{Access Token}, maka \textit{Request Token} sudah tidak berlaku lagi. Anda dapat menggunakan Access Token untuk sistem \textit{file} dengan melakukan seriliasi objek, atau dengan mendapatkan token dan secret dari AccesToken\#getToken() dan AccessToken\#getTokenSecret().
%	\begin{lstlisting} [caption= code untuk mmendapatkan \textit{token} dan \textit{tokenSecret}]
%	{
%		public static void main(String args[]) throws Exception{
%			// The factory instance is re-useable and thread safe.
%			TwitterFactory factory = new TwitterFactory();
%			AccessToken accessToken = loadAccessToken(Integer.parseInt(args[0]));
%			Twitter twitter = factory.getInstance);
%			twitter.setOAuthConsumerKey("[consumer key]", "[consumer secret]");
%			twitter.setOAuthAccessToken(accessToken);
%			Status status = twitter.updateStatus(args[1]);
%			System.out.println("Successfully updated the status to [" + status.getText() + "].");
%			System.exit(0);
%		}
%		private static AccessToken loadAccessToken(int useId){
%			String token = // load from a persistent store
%			String tokenSecret = // load from a persistent store
%			return new AccessToken(token, tokenSecret);
%		}
%  }
%	\end{lstlisting}
	
%	\item \textit{Streaming API}
%	\textit{TwitterStream class} memiliki beberapa method yang telah disiapkan untuk \textit{Streaming API}. Yang anda perlukan hanya mengimplementasikan \textit{StatusListener}. Berikut adalah contoh kodenya:
%	\begin{lstlisting} [caption= contoh code untuk Streaming API]
%	{
%		public static void main(String[] args) throws TwitterException, IOException{
%			StatusListener listener = new StatusListener(){
%					public void onStatus(Status status) {
%							System.out.println(status.getUser().getName() + " : " + status.getText());
%					}
%					public void onDeletionNotice(StatusDeletionNotice statusDeletionNotice) {}
%					public void onTrackLimitationNotice(int numberOfLimitedStatuses) {}
%					public void onException(Exception ex) {
%							ex.printStackTrace();
%					}
%			};
%			TwitterStream twitterStream = new TwitterStreamFactory().getInstance();
%			twitterStream.addListener(listener);
%			// sample() method internally creates a thread which manipulates TwitterStream and calls these adequate listener methods continuously.
%			twitterStream.sample();
%		}
%  }
%	\end{lstlisting}
%\end{itemize}